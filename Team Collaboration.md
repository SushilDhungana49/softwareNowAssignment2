# Team Collaboration

## Question 1 (Contributor - Sushil Dhungana)
The encryption and decryption script was developed by carefully studying the character transformation rules and breaking them into clear cases for lowercase and uppercase letters based on their positions in the alphabet (a–m/n–z and A–M/N–Z). The developer first focused on building simple, reliable functions to encrypt and decrypt individual characters, using modular arithmetic to handle shifts and wrap-around within the 13-letter ranges, while ensuring the process could always be reversed. File handling was then added to read text from raw_text.txt, write the encrypted output to encrypted_text.txt, and restore the original content in decrypted_text.txt, with basic error handling to manage missing files or read/write issues. To make the program easier to use, a validated user input for shift values and a verification step to compare the original and decrypted files were included. The overall flow was managed through a main function, and throughout the process, attention was given to clean structure, clear docstrings, and handling edge cases such as leaving non-alphabetic characters unchanged, resulting in a practical and well-structured Python program.

## Question 2 (Contributor - Pramisha Shrestha & Prabesh Tamang)
This code was written by first understanding the structure of the temperature CSV files and deciding what insights were needed from the data, such as seasonal averages, temperature ranges, and station stability. The work started with organizing constants like seasons and the data folder to keep everything clear and easy to update. From there, the focus was on building small, readable functions, beginning with reading and validating temperature data across all files, while handling missing or invalid values safely. Once the data was collected, separate functions were created to calculate seasonal averages, identify the station with the largest temperature range, and measure temperature stability using standard deviation. Each step was kept modular so different parts of the analysis could be tested or modified independently. File outputs were added to clearly record results, and the overall process was tied together in a main function to keep the program flow simple and easy to follow, making the code straightforward for team members to understand and collaborate on.

### Development Methodology
This project was developed using pair programming.
Driver and Navigator roles were rotated as per questions.

## Question 3 (Contributor - Fuad Ahmed Anonto)
This code was written by starting with the core idea of breaking a single edge into smaller segments using recursion, inspired by fractal-style patterns. The focus was first on getting the recursive logic right, where each line segment is divided into thirds and redrawn with specific angle turns to create the inward indentation, while keeping the base case simple so the turtle just moves forward when the recursion depth reaches zero. Once the recursive edge worked correctly, it was wrapped inside a loop that draws a regular polygon, allowing the same pattern to be applied to any number of sides. User input was added for flexibility, so the number of sides, side length, and recursion depth can be changed without modifying the code. Extra care was taken to position the turtle near the center of the screen for better visuals and to keep the program readable by separating the drawing logic from the setup and input handling, making it easier for teammates to understand, modify, or extend the pattern later.

